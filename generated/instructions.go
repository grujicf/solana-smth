// Code generated by https://github.com/gagliardetto/anchor-go. DO NOT EDIT.
// This file contains instructions.

package skyline_program

import (
	"bytes"
	"fmt"
	errors "github.com/gagliardetto/anchor-go/errors"
	binary "github.com/gagliardetto/binary"
	solanago "github.com/gagliardetto/solana-go"
)

// Builds a "bridge_request" instruction.
// Create a cross-chain bridging request and transfer source tokens to vault. //  // This instruction creates a bridging request for transferring tokens to another chain. // The source tokens are transferred to the vault account immediately, and a request is created // that can be processed by validators to transfer equivalent tokens on the destination chain. //  // # Arguments // * `ctx` - The context containing accounts for the bridge request // * `amount` - The amount of tokens to bridge // * `receiver` - The receiver's address on the destination chain (57 bytes) // * `destination_chain` - The chain ID of the destination blockchain //  // # Errors // * `InsufficientFunds` - If the sender doesn't have enough tokens
func NewBridgeRequestInstruction(
	// Params:
	amountParam uint64,
	receiverParam [57]uint8,
	destinationChainParam uint8,

	// Accounts:
	signerAccount solanago.PublicKey,
	signersAtaAccount solanago.PublicKey,
	vaultAccount solanago.PublicKey,
	vaultAtaAccount solanago.PublicKey,
	bridgingRequestAccount solanago.PublicKey,
	mintAccount solanago.PublicKey,
	tokenProgramAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
	associatedTokenProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_BridgeRequest[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `amountParam`:
		err = enc__.Encode(amountParam)
		if err != nil {
			return nil, errors.NewField("amountParam", err)
		}
		// Serialize `receiverParam`:
		err = enc__.Encode(receiverParam)
		if err != nil {
			return nil, errors.NewField("receiverParam", err)
		}
		// Serialize `destinationChainParam`:
		err = enc__.Encode(destinationChainParam)
		if err != nil {
			return nil, errors.NewField("destinationChainParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "signer": Writable, Signer, Required
		// The user initiating the bridge request
		accounts__.Append(solanago.NewAccountMeta(signerAccount, true, true))
		// Account 1 "signers_ata": Writable, Non-signer, Required
		// The user's associated token account for the tokens being bridged
		accounts__.Append(solanago.NewAccountMeta(signersAtaAccount, true, false))
		// Account 2 "vault": Writable, Non-signer, Required
		// The vault account
		accounts__.Append(solanago.NewAccountMeta(vaultAccount, true, false))
		// Account 3 "vault_ata": Writable, Non-signer, Required
		// The vault associated token account for the tokens being bridged
		accounts__.Append(solanago.NewAccountMeta(vaultAtaAccount, true, false))
		// Account 4 "bridging_request": Writable, Non-signer, Required
		// The bridging request account to be created
		accounts__.Append(solanago.NewAccountMeta(bridgingRequestAccount, true, false))
		// Account 5 "mint": Writable, Non-signer, Required
		// The token mint for the tokens being bridged
		accounts__.Append(solanago.NewAccountMeta(mintAccount, true, false))
		// Account 6 "token_program": Read-only, Non-signer, Required, Address: TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA
		// The token program for burning operations
		accounts__.Append(solanago.NewAccountMeta(tokenProgramAccount, false, false))
		// Account 7 "system_program": Read-only, Non-signer, Required
		// The system program for account creation
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
		// Account 8 "associated_token_program": Read-only, Non-signer, Required, Address: ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL
		// The associated token program for creating token accounts
		accounts__.Append(solanago.NewAccountMeta(associatedTokenProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "bridge_transaction" instruction.
// Create or approve a bridging transaction. //  // This instruction creates or approves a bridging transaction for transferring tokens from the vault // to a recipient. The first call creates the transaction, and subsequent calls from validators approve it. // Once the consensus threshold is met, the tokens are automatically transferred from the vault to the // recipient's associated token account, and the transaction account is closed. //  // # Arguments // * `ctx` - The context containing accounts for the bridging transaction // * `amount` - The amount of tokens to transfer to the recipient // * `batch_id` - The batch ID of the transaction (must be greater than last_batch_id) //  // # Errors // * `InvalidBatchId` - If the batch_id is not greater than the last_batch_id // * `InvalidReceiver` - If the receiver is the same as the payer // * `NoSignersProvided` - If no validator signers are provided // * `SignerAlreadyApproved` - If a signer has already approved this transaction // * `NotEnoughSigners` - If insufficient validators have signed (checked when threshold is met) // * `InvalidSigner` - If a signer is not in the validator set
func NewBridgeTransactionInstruction(
	// Params:
	amountParam uint64,
	batchIdParam uint64,

	// Accounts:
	payerAccount solanago.PublicKey,
	validatorSetAccount solanago.PublicKey,
	bridgingTransactionAccount solanago.PublicKey,
	mintTokenAccount solanago.PublicKey,
	recipientAccount solanago.PublicKey,
	recipientAtaAccount solanago.PublicKey,
	vaultAccount solanago.PublicKey,
	vaultAtaAccount solanago.PublicKey,
	tokenProgramAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
	associatedTokenProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_BridgeTransaction[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `amountParam`:
		err = enc__.Encode(amountParam)
		if err != nil {
			return nil, errors.NewField("amountParam", err)
		}
		// Serialize `batchIdParam`:
		err = enc__.Encode(batchIdParam)
		if err != nil {
			return nil, errors.NewField("batchIdParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "payer": Writable, Signer, Required
		// The payer for any associated token account creation
		accounts__.Append(solanago.NewAccountMeta(payerAccount, true, true))
		// Account 1 "validator_set": Writable, Non-signer, Required
		// The validator set account for consensus validation
		accounts__.Append(solanago.NewAccountMeta(validatorSetAccount, true, false))
		// Account 2 "bridging_transaction": Writable, Non-signer, Required
		// The bridging transaction account to be created
		accounts__.Append(solanago.NewAccountMeta(bridgingTransactionAccount, true, false))
		// Account 3 "mint_token": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(mintTokenAccount, true, false))
		// Account 4 "recipient": Read-only, Non-signer, Required
		// The recipient of the bridged tokens
		accounts__.Append(solanago.NewAccountMeta(recipientAccount, false, false))
		// Account 5 "recipient_ata": Writable, Non-signer, Required
		// The recipient's associated token account for the mint
		accounts__.Append(solanago.NewAccountMeta(recipientAtaAccount, true, false))
		// Account 6 "vault": Writable, Non-signer, Required
		// The vault account
		accounts__.Append(solanago.NewAccountMeta(vaultAccount, true, false))
		// Account 7 "vault_ata": Writable, Non-signer, Required
		// The vault associated token account for the mint
		accounts__.Append(solanago.NewAccountMeta(vaultAtaAccount, true, false))
		// Account 8 "token_program": Read-only, Non-signer, Required, Address: TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA
		// The token program for minting operations
		accounts__.Append(solanago.NewAccountMeta(tokenProgramAccount, false, false))
		// Account 9 "system_program": Read-only, Non-signer, Required
		// The system program for account creation
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
		// Account 10 "associated_token_program": Read-only, Non-signer, Required, Address: ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL
		// The associated token program for creating token accounts
		accounts__.Append(solanago.NewAccountMeta(associatedTokenProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "bridge_vsu" instruction.
// Create or approve a validator set update (VSU) for the bridge. //  // This instruction allows changing the set of validators that control bridge operations. // The first call creates a validator set change proposal, and subsequent calls from validators // approve the proposal. Requires approval from the current validator set meeting the consensus // threshold and maintains the same validation rules as initialization (unique validators, 4-10 count). //  // # Arguments // * `ctx` - The context containing accounts for creating or approving the validator set change // * `added` - Vector of new validator public keys to add // * `removed` - Vector of validator indexes to remove // * `batch_id` - The batch ID of the validator set change (must be greater than last_batch_id) //  // # Errors // * `MaxValidatorsExceeded` - If more than 10 validators would result from the change // * `MinValidatorsNotMet` - If fewer than 4 validators would result from the change // * `AddingExistingSigner` - If attempting to add a validator that already exists // * `InvalidBatchId` - If the batch_id is not greater than the last_batch_id // * `InvalidProposalHash` - If approving a proposal with a different hash than the original // * `NoSignersProvided` - If no validator signers are provided // * `NotEnoughSigners` - If insufficient current validators have signed (checked when threshold is met) // * `InvalidSigner` - If a signer is not in the current validator set
func NewBridgeVsuInstruction(
	// Params:
	addedParam []solanago.PublicKey,
	removedParam []uint64,
	batchIdParam uint64,

	// Accounts:
	payerAccount solanago.PublicKey,
	validatorSetAccount solanago.PublicKey,
	validatorSetChangeAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_BridgeVsu[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `addedParam`:
		err = enc__.Encode(addedParam)
		if err != nil {
			return nil, errors.NewField("addedParam", err)
		}
		// Serialize `removedParam`:
		err = enc__.Encode(removedParam)
		if err != nil {
			return nil, errors.NewField("removedParam", err)
		}
		// Serialize `batchIdParam`:
		err = enc__.Encode(batchIdParam)
		if err != nil {
			return nil, errors.NewField("batchIdParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "payer": Writable, Signer, Required
		// The payer for any associated token account creation
		accounts__.Append(solanago.NewAccountMeta(payerAccount, true, true))
		// Account 1 "validator_set": Writable, Non-signer, Required
		// The validator set account to be updated
		accounts__.Append(solanago.NewAccountMeta(validatorSetAccount, true, false))
		// Account 2 "validator_set_change": Writable, Non-signer, Required
		// The validator set change account to be created
		accounts__.Append(solanago.NewAccountMeta(validatorSetChangeAccount, true, false))
		// Account 3 "system_program": Read-only, Non-signer, Required
		// The system program for account creation
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "close_request" instruction.
// Close a bridging request account. //  // This instruction closes a bridging request account, typically called after // the request has been processed or cancelled. Requires validator approval. //  // # Arguments // * `ctx` - The context containing accounts for closing the request //  // # Errors // * `NotEnoughSigners` - If insufficient validators have signed // * `InvalidSigner` - If a signer is not in the validator set
func NewCloseRequestInstruction(
	signerAccount solanago.PublicKey,
	bridgingRequestAccount solanago.PublicKey,
	validatorSetAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "signer": Writable, Signer, Required
		// The signer who will receive the rent from closing the account
		accounts__.Append(solanago.NewAccountMeta(signerAccount, true, true))
		// Account 1 "bridging_request": Writable, Non-signer, Required
		// The bridging request account to be closed
		accounts__.Append(solanago.NewAccountMeta(bridgingRequestAccount, true, false))
		// Account 2 "validator_set": Read-only, Non-signer, Required
		// The validator set account for consensus validation
		accounts__.Append(solanago.NewAccountMeta(validatorSetAccount, false, false))
		// Account 3 "system_program": Read-only, Non-signer, Required
		// The system program for account closure
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		nil,
	), nil
}

// Builds a "initialize" instruction.
// Initialize the validator set and vault for the bridge system. //  // This instruction sets up the initial validator set that will control all bridge operations // and creates the vault account that will hold bridged tokens. The validators must be unique // and meet the minimum/maximum requirements. The consensus threshold is automatically calculated // as 2/3 of the validator count (rounded up). //  // # Arguments // * `ctx` - The context containing accounts for initialization // * `validators` - Vector of validator public keys (4-10 validators required) // * `last_id` - Optional initial batch ID (defaults to 0 if not provided) //  // # Errors // * `MaxValidatorsExceeded` - If more than 10 validators are provided // * `MinValidatorsNotMet` - If fewer than 4 validators are provided // * `ValidatorsNotUnique` - If duplicate validators are provided
func NewInitializeInstruction(
	// Params:
	validatorsParam []solanago.PublicKey,
	lastIdParam *uint64,

	// Accounts:
	signerAccount solanago.PublicKey,
	validatorSetAccount solanago.PublicKey,
	vaultAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_Initialize[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `validatorsParam`:
		err = enc__.Encode(validatorsParam)
		if err != nil {
			return nil, errors.NewField("validatorsParam", err)
		}
		// Serialize `lastIdParam` (optional):
		{
			if lastIdParam == nil {
				err = enc__.WriteOption(false)
				if err != nil {
					return nil, errors.NewOption("lastIdParam", fmt.Errorf("error while encoding optionality: %w", err))
				}
			} else {
				err = enc__.WriteOption(true)
				if err != nil {
					return nil, errors.NewOption("lastIdParam", fmt.Errorf("error while encoding optionality: %w", err))
				}
				err = enc__.Encode(lastIdParam)
				if err != nil {
					return nil, errors.NewField("lastIdParam", err)
				}
			}
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "signer": Writable, Signer, Required
		// The signer who is initializing the bridge system
		accounts__.Append(solanago.NewAccountMeta(signerAccount, true, true))
		// Account 1 "validator_set": Writable, Non-signer, Required
		// The validator set account to be initialized
		accounts__.Append(solanago.NewAccountMeta(validatorSetAccount, true, false))
		// Account 2 "vault": Writable, Non-signer, Required
		// The vault account
		accounts__.Append(solanago.NewAccountMeta(vaultAccount, true, false))
		// Account 3 "system_program": Read-only, Non-signer, Required
		// The system program for account creation
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}
